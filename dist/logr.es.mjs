function e(e){const t=Object.values(e);if(0===t.length)return 1;const n=Math.max(...t);if(n<=0)return 1;return 1<<Math.floor(Math.log2(n))+1}function t(e,t=1){return Object.freeze(e.reduce(((e,n,o)=>(e[n]=t<<o,e)),{}))}function n(o,r){if(Array.isArray(r)){return n(o,t(r,e(o)))}const s=e(o),l={...o},c=Object.entries(r);let a=1/0;for(const[,e]of c)e>0&&e<a&&(a=e);const f=a===1/0||a>=s?0:Math.floor(Math.log2(s/a));for(const[e,t]of c)e in l||(l[e]=0===t?0:t<<f);return Object.freeze(l)}function o(e,t){const n={...e},o=new Set(Object.values(e)),r=Math.max(0,...o);let s=r?Math.floor(Math.log2(r))+1:0;for(const[e,r]of Object.entries(t))if(e in n)console.assert(n[e]===r,`Key '${e}' has conflicting values: ${n[e]} (obj_labels1) vs ${r} (obj_labels2)`);else{let t=r;for(;o.has(t);)t=1<<s++;n[e]=t,o.add(t)}return Object.freeze(n)}function r(e,t){const n={};for(const[o,r]of Object.entries(e))n[o]=r<<t;return Object.freeze(n)}function s(e,t){const n={};for(const[o,r]of Object.entries(e))n[o]=r>>t;return Object.freeze(n)}function l(){var e=Array.prototype.slice.call(arguments);console.log.apply(console,e)}const c=function(){let e;function t(){let e,t=l,n=BigInt(0);return{set handler(e){t=e},get handler(){return t},get labels(){return e},set labels(t){e=t,n=BigInt(0)},get toggled(){return n},set toggled(t){n=function(e,t,n=!1){console.assert(void 0!==e,"no labels initialized");let o=BigInt(0);for(const[r,s]of Object.entries(t))(n||s)&&e[r]&&(o|=BigInt(e[r]));return o}(e,t)},log(e,t){}}}return{instance:()=>(e||(e=t()),e)}}();export{c as LOGR,r as l_LL,s as l_RR,t as l_array,n as l_concat,e as l_length,o as l_merge};
